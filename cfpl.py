from ortools.linear_solver import pywraplp

def solve_cfpl():
    t = 'CFPL'
    s = pywraplp.Solver(t, pywraplp.Solver.GLOP_LINEAR_PROGRAMMING)
    Qualities, Venders, Thinknesses, Grades, GradesPairs = range(2), range(2), range(2), range(3), range(3)
    w = [[[s.NumVar(0, 1000, '') for _ in Thinknesses] for _ in Venders] for _ in Qualities] # 和数据公式里的顺序相反
    x_limits = [[5000, 25000, 40000],[10000, 40000, 50000]]
    x = [[s.NumVar(0, x_limits[j][i], '') for i in Grades] for j in Thinknesses]
    y = [[[s.NumVar(0,30000, '') for _ in Grades] for _ in Grades] for _ in Thinknesses]

    z_limits = [[1000, 4000, 8000], [1000, 5000, 8000]]
    z = [[s.NumVar(0, z_limits[j][i], '') for i in Grades] for j in Thinknesses]

    s.Add(w[0][0][0] + w[0][0][1] <= 200)
    s.Add(w[1][0][0] + w[1][0][1] <= 300)
    s.Add(w[0][1][0] + w[0][1][1] <= 100)
    s.Add(w[1][1][0] + w[1][1][1] <= 1000)
    s.Add(0.25*(z[0][0] + z[0][1] + z[0][2]) + 0.40*(z[1][0] + z[1][1] + z[1][2]) <= 4500) 

    s.Add(400*w[0][0][0] + 200*w[1][0][0] + 400*w[0][1][0] + 200*w[1][1][0] + x[0][0] >= 35*y[0][0][0] + 35*y[0][0][1])
    s.Add(700*w[0][0][0] + 500*w[1][0][0] + 700*w[0][1][0] + 500*w[1][1][0] + x[0][1] >= 35*y[0][1][0] + 35*y[0][1][1] + 35*y[0][1][2])
    s.Add(900*w[0][0][0] + 1300*w[1][0][0] + 900*w[0][1][0] + 1300*w[1][1][0] + x[0][2] >= 35*y[0][2][1] + 35*y[0][2][2]) 
    s.Add(200*w[0][0][1] + 100*w[1][0][1] + 200*w[0][1][1] + 100*w[1][1][1] + x[1][0] >= 35*y[1][0][0] + 35*y[1][0][1])
    s.Add(350*w[0][0][1] + 250*w[1][0][1] + 350*w[0][1][1] + 250*w[1][1][1] + x[1][1] >= 35*y[1][1][0] + 35*y[1][1][1] + 35*y[1][1][2])
    s.Add(450*w[0][0][1] + 650*w[1][0][1] + 450*w[0][1][1] + 650*w[1][1][1] + x[1][2] >= 35*y[1][2][1] + 35*y[1][2][2])

    s.Add(y[0][0][0] + y[0][1][0] == z[0][0] + z[0][1] + z[1][0] + z[1][1])
    s.Add(y[0][0][1] + y[0][1][1] + y[0][2][1] == z[0][0] + z[0][2] + z[1][0] + z[1][2]) 
    s.Add(y[0][1][2] + y[0][2][2] == z[0][1] + z[0][2] + z[1][1] + z[1][2])
    s.Add(y[1][0][1] + y[1][1][1] + y[1][2][1] == z[1][0] + z[1][1] + z[1][2])
    s.Add(y[1][1][2] + y[1][2][2] == z[0][0] + z[0][1] + z[0][2] + 2*z[1][0] + 2*z[1][1] + 2*z[1][2])

    obj = s.NumVar(0, 10000000, 'obj')
    s.Add(obj ==-(340*w[0][0][0] + 190*w[1][0][0] + 490*w[0][1][0] + 140*w[1][1][0] + 340*w[0][0][1] + 190*w[1][0][1] + 490*w[0][1][1] + 140*w[1][1][1]) - (1.00*x[0][0] + 0.30*x[0][1] + 0.10*x[0][2] + 2.2*x[1][0] + 0.60*x[1][1] + 0.2*x[1][2]) + (45*z[0][0] + 40*z[0][1] + 33*z[0][2] + 75*z[1][0] + 65*z[1][1] + 50*z[1][2]))
    
    s.Maximize(obj)

    s.Solve()

    return obj.SolutionValue(), w, x, y, z



obj, w, x, y, z = solve_cfpl()
print('complete.')






